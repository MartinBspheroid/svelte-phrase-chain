#!/usr/bin/env node
import inquirer from 'inquirer';
import fs from 'fs';
import path from 'path';

async function main() {
  const [,, command] = process.argv;

  if (command !== 'init') {
    console.log('Usage: svelte-phrase-chain init');
    process.exit(1);
  }

  console.log('Welcome to svelte-phrase-chain init!');

  
  const localesAnswer = await inquirer.prompt([
    {
      type: 'input',
      name: 'locales',
      message: 'Enter supported locales (comma-separated)',
      default: 'en, es, fr',
      filter: (input: string) => input.split(',').map(s => s.trim()).filter(Boolean)
    }
  ]);

  const locales: string[] = localesAnswer.locales;

  const fallbackAnswer = await inquirer.prompt([
    {
      type: 'input',
      name: 'fallbackLocale',
      message: 'Enter fallback locale',
      default: 'en',
      validate: (input: string) => {
        if (!locales.includes(input.trim())) {
          return 'Fallback locale must be one of the supported locales';
        }
        return true;
      }
    }
  ]);

  const otherAnswers = await inquirer.prompt([
    {
      type: 'confirm',
      name: 'persistLocale',
      message: 'Persist locale in localStorage?',
      default: true
    },
    {
      type: 'input',
      name: 'localStorageKey',
      message: 'LocalStorage key for locale',
      default: 'app_locale'
    },
    {
      type: 'input',
      name: 'translationsDir',
      message: 'Translations folder path',
      default: 'src/lib/translations'
    },
    {
      type: 'confirm',
      name: 'generateTranslations',
      message: 'Generate initial translation JSON files?',
      default: true
    },
    {
      type: 'confirm',
      name: 'debug',
      message: 'Enable debug logging?',
      default: true
    }
  ]);

  const fallbackLocale: string = fallbackAnswer.fallbackLocale;
  const {
    persistLocale,
    localStorageKey,
    translationsDir,
    generateTranslations,
    debug
  } = otherAnswers;

  // Ensure translations directory exists
  if (!fs.existsSync(translationsDir)) {
    fs.mkdirSync(translationsDir, { recursive: true });
    console.log(`Created translations directory: ${translationsDir}`);
  }

  // Generate initial translation files
  if (generateTranslations) {
    for (const locale of locales) {
      const filePath = path.join(translationsDir, `${locale}.json`);
      if (!fs.existsSync(filePath)) {
        const content = {
          greeting: locale === 'en' ? 'Hello' : ''
        };
        fs.writeFileSync(filePath, JSON.stringify(content, null, 2), 'utf-8');
        console.log(`Created ${filePath}`);
      } else {
        console.log(`Skipped existing ${filePath}`);
      }
    }
  }

  // Generate i18n.svelte.ts content
  const localeUnion = locales.map((l: string) => `'${l}'`).join(' | ');

  const i18nContent = `// Auto-generated by svelte-phrase-chain init
import { dev } from "$app/environment";
import en from '$lib/translations/en.json';
import type { Paths } from "./types";

export type Locale = ${localeUnion};

export interface I18nConfig {
  persistLocale: boolean;
  localStorageKey: string;
  fallbackLocale: Locale;
  debug: boolean;
}

export type TranslationValue = string | PluralObject | NestedTranslations;
export interface PluralObject {
  [pluralForm: string]: string;
}
export type NestedTranslations = {
  [key: string]: TranslationValue;
}

type Translations = Record<Locale, Paths<typeof en>>;
export type TranslationKey = Paths<typeof en>;

export interface InitLocaleOptions {
  preferBrowser?: boolean;
  preferStorage?: boolean;
  defaultLocale?: Locale;
}

export interface SetLocaleOptions {
  silent?: boolean;
}

export interface I18nActionOptions {
  key: string;
  params?: Record<string, unknown>;
  count?: number;
}

const config: I18nConfig = {
  persistLocale: ${persistLocale},
  localStorageKey: '${localStorageKey}',
  fallbackLocale: '${fallbackLocale}',
  debug: ${debug} && dev
};

const translations = $state<Translations>({
  en
} as unknown as Translations);

let currentLocale = $state<Locale>(getSavedLocale());
export const locale = () => currentLocale;
const failedLocaleLoads = $state<Partial<Record<Locale, boolean>>>({});

function isValidLocale(locale: string | null | undefined): locale is Locale {
  return typeof locale === 'string' && [${locales.map((l: string) => `'${l}'`).join(', ')}].includes(locale);
}

function getSavedLocale(): Locale {
  if (config.persistLocale && typeof window !== 'undefined') {
    try {
      const saved = localStorage.getItem(config.localStorageKey);
      if (isValidLocale(saved)) {
        return saved;
      }
    } catch (e) {
      if (config.debug) console.error("Failed to read locale from localStorage:", e);
    }
  }
  return config.fallbackLocale;
}

export function detectBrowserLocale(): Locale {
  if (typeof navigator === 'undefined') return config.fallbackLocale;
  const browserLang = navigator.language.split('-')[0];
  return isValidLocale(browserLang) ? browserLang : config.fallbackLocale;
}

function getNestedValue(obj: NestedTranslations | undefined, path: string): TranslationValue | undefined {
  if (!obj) return undefined;
  return path.split('.').reduce<TranslationValue | undefined>((prev, curr) => {
    if (typeof prev === 'object' && prev !== null && !Array.isArray(prev) && !(prev instanceof Date) && curr in prev) {
      return (prev as NestedTranslations)[curr];
    }
    return undefined;
  }, obj as TranslationValue);
}

function findTranslationValue(key: string, primaryLocale: Locale, fallbackLocale: Locale, allTranslations: Translations): TranslationValue | undefined {
  const primaryObj = allTranslations[primaryLocale] as unknown as NestedTranslations | undefined;
  let value = getNestedValue(primaryObj, key);

  if (value === undefined && primaryLocale !== fallbackLocale) {
    const fallbackObj = allTranslations[fallbackLocale] as unknown as NestedTranslations | undefined;
    value = getNestedValue(fallbackObj, key);
    if (config.debug && value !== undefined) {
      console.warn(\`Translation key '\${key}' not found in '\${primaryLocale}', using fallback '\${fallbackLocale}'.\`);
    }
  }
  return value;
}

function applyParams(str: string, params?: Record<string, unknown>): string {
  if (!params) return str;
  return str.replace(/{([^{}]+)}/g, (match, expr) => {
    const key = expr.trim().split(':')[0].trim();
    if (Object.prototype.hasOwnProperty.call(params, key)) {
      const value = params[key];
      return value == null ? '' : String(value);
    }
    return '';
  });
}

export function configure(options: Partial<I18nConfig>): void {
  if (options.persistLocale !== undefined) config.persistLocale = options.persistLocale;
  if (options.localStorageKey !== undefined) config.localStorageKey = options.localStorageKey;
  if (options.fallbackLocale !== undefined) config.fallbackLocale = options.fallbackLocale;
  config.debug = options.debug !== undefined ? options.debug : dev;
}

export function initLocale(options: InitLocaleOptions = {}): void {
  const opts: Required<InitLocaleOptions> = {
    preferBrowser: true,
    preferStorage: true,
    defaultLocale: config.fallbackLocale,
    ...options
  };

  let detectedLocale: Locale | null = null;

  if (opts.preferStorage && config.persistLocale) {
    const saved = getSavedLocale();
    if (saved !== config.fallbackLocale) detectedLocale = saved;
  }

  if (!detectedLocale && opts.preferBrowser) {
    const browserLocale = detectBrowserLocale();
    if (browserLocale !== config.fallbackLocale) detectedLocale = browserLocale;
  }

  void setLocale(detectedLocale ?? opts.defaultLocale, { silent: true });

  if (config.debug) {
    console.log(\`i18n initialized. Locale set to: \${currentLocale}.\`);
  }
}

export async function setLocale(newLocale: Locale, options: SetLocaleOptions = {}): Promise<void> {
  const { silent = false } = options;

  if (failedLocaleLoads[newLocale]) {
    if (!silent) console.warn(\`Locale '\${newLocale}' previously failed to load. Using fallback '\${config.fallbackLocale}'.\`);
    if (currentLocale === newLocale) currentLocale = config.fallbackLocale;
    return;
  }

  currentLocale = newLocale;

  if (newLocale !== 'en' && !translations[newLocale]) {
    if (config.debug) console.log(\`Loading translations for locale: \${newLocale}\`);
    try {
      const module = await import(\`./translations/\${newLocale}.json\`);
      translations[newLocale] = module.default as unknown as Paths<typeof en>;
      failedLocaleLoads[newLocale] = false;
      if (config.debug) console.log(\`Successfully loaded locale: \${newLocale}\`);
    } catch (error) {
      failedLocaleLoads[newLocale] = true;
      if (!silent) console.error(\`Failed to load translations for locale: \${newLocale}\`, error);
      if (currentLocale === newLocale) {
        currentLocale = config.fallbackLocale;
        if (!silent) console.warn(\`Falling back to locale: \${config.fallbackLocale}\`);
      }
    }
  } else if (translations[newLocale]) {
    if (config.debug) console.log(\`Locale switched to already loaded: \${newLocale}\`);
  }
}

export function t(
  key: Translations[Locale],
  params?: Record<string, unknown>,
  count?: number
): string {
  const localeToUse = currentLocale;
  const translationValue = findTranslationValue(key, localeToUse, config.fallbackLocale, translations);

  if (translationValue !== undefined) {
    if (typeof translationValue === 'object' && translationValue !== null && count !== undefined) {
      const pluralForm = (translationValue as PluralObject)[count === 1 ? 'one' : 'other'] ?? (translationValue as PluralObject)['other'];
      if (typeof pluralForm === 'string') {
        return applyParams(pluralForm, { ...params, count });
      }
    } else if (typeof translationValue === 'string') {
      return applyParams(translationValue, params);
    }
  }

  if (config.debug) {
    console.warn(\`Translation key not found: '\${key}' (locale: \${localeToUse})\`);
    return \`[\${key}]\`;
  }

  const parts = key.split('.');
  return parts[parts.length - 1] || key;
}

declare global {
  interface Window {
    __i18nMissingKeys?: Set<string>;
  }
}
`;

  const i18nPath = path.join('src', 'lib', 'i18n.svelte.ts');
  fs.mkdirSync(path.dirname(i18nPath), { recursive: true });
  fs.writeFileSync(i18nPath, i18nContent, 'utf-8');
  console.log(`Generated ${i18nPath}`);
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});
