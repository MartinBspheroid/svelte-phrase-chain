// Auto-generated by svelte-phrase-chain init
import { dev } from "$app/environment";
import en from '$lib/translations/en.json';
export type Paths<T, P extends string = ''> = T extends Readonly<Record<string, unknown>> // Is it an object-like structure?
    ? P extends '' // Handle root level keys separately
        ? { // Iterate over keys K at the root
              [K in keyof T & string]:
                  | K // The key itself is a path
                  | Paths<T[K], K>; // Recurse with K as the initial prefix
          }[keyof T & string]
        : T extends ReadonlyArray<unknown> // Is it an array?
            ? P // Stop at the array path itself
            : { // Iterate over keys K within the nested object
                  [K in keyof T & string]:
                      | `${P}.${K}` // Path to the nested key/node
                      | Paths<T[K], `${P}.${K}`>; // Recurse further
              }[keyof T & string]
    : P; // Leaf node or array reached, return the path built so far


export type Locale = 'en' | 'es' | 'fr';

export interface I18nConfig {
  persistLocale: boolean;
  localStorageKey: string;
  fallbackLocale: Locale;
  debug: boolean;
}

export type TranslationValue = string | PluralObject | NestedTranslations;
export interface PluralObject {
  [pluralForm: string]: string;
}
export type NestedTranslations = {
  [key: string]: TranslationValue;
}

type Translations = Record<Locale, Paths<typeof en>>;
export type TranslationKey = Paths<typeof en>;

export interface InitLocaleOptions {
  preferBrowser?: boolean;
  preferStorage?: boolean;
  defaultLocale?: Locale;
}

export interface SetLocaleOptions {
  silent?: boolean;
}

export interface I18nActionOptions {
  key: string;
  params?: Record<string, unknown>;
  count?: number;
}

const config: I18nConfig = {
  persistLocale: true,
  localStorageKey: 'app_locale',
  fallbackLocale: 'en',
  debug:  dev
};

const translations = $state<Translations>({
  en
} as unknown as Translations);

let currentLocale = $state<Locale>(getSavedLocale());
export const locale = () => currentLocale;
const failedLocaleLoads = $state<Partial<Record<Locale, boolean>>>({});

function isValidLocale(locale: string | null | undefined): locale is Locale {
  return typeof locale === 'string' && (['en', 'es', 'fr'].includes(locale));
}

function getSavedLocale(): Locale {
  if (config.persistLocale && typeof window !== 'undefined') {
    try {
      const saved = localStorage.getItem(config.localStorageKey);
      if (isValidLocale(saved)) {
        return saved;
      }
    } catch (e) {
      if (config.debug) console.error("Failed to read locale from localStorage:", e);
    }
  }
  return config.fallbackLocale;
}

export function detectBrowserLocale(): Locale {
  if (typeof navigator === 'undefined') return config.fallbackLocale;
  const browserLang = navigator.language.split('-')[0];
  return isValidLocale(browserLang) ? browserLang : config.fallbackLocale;
}

function getNestedValue(obj: NestedTranslations | undefined, path: string): TranslationValue | undefined {
  if (!obj) return undefined;
  return path.split('.').reduce<TranslationValue | undefined>((prev, curr) => {
    if (typeof prev === 'object' && prev !== null && !Array.isArray(prev) && !(prev instanceof Date) && curr in prev) {
      return (prev as NestedTranslations)[curr];
    }
    return undefined;
  }, obj as TranslationValue);
}

function findTranslationValue(key: string, primaryLocale: Locale, fallbackLocale: Locale, allTranslations: Translations): TranslationValue | undefined {
  const primaryObj = allTranslations[primaryLocale] as unknown as NestedTranslations | undefined;
  let value = getNestedValue(primaryObj, key);

  if (value === undefined && primaryLocale !== fallbackLocale) {
    const fallbackObj = allTranslations[fallbackLocale] as unknown as NestedTranslations | undefined;
    value = getNestedValue(fallbackObj, key);
    if (config.debug && value !== undefined) {
      console.warn(`Translation key '${key}' not found in '${primaryLocale}', using fallback '${fallbackLocale}'.`);
    }
  }
  return value;
}

function applyParams(str: string, params?: Record<string, unknown>): string {
  if (!params) return str;
  return str.replace(/{([^{}]+)}/g, (match, expr) => {
    const key = expr.trim().split(':')[0].trim();
    if (Object.prototype.hasOwnProperty.call(params, key)) {
      const value = params[key];
      return value == null ? '' : String(value);
    }
    return '';
  });
}

const pluralRulesCache: Partial<Record<Locale, Intl.PluralRules>> = {};

function getPluralCategory(locale: Locale, count: number): string {
  if (!pluralRulesCache[locale]) {
    pluralRulesCache[locale] = new Intl.PluralRules(locale);
  }
  return pluralRulesCache[locale].select(count);
}

export function configure(options: Partial<I18nConfig>): void {
  if (options.persistLocale !== undefined) config.persistLocale = options.persistLocale;
  if (options.localStorageKey !== undefined) config.localStorageKey = options.localStorageKey;
  if (options.fallbackLocale !== undefined) config.fallbackLocale = options.fallbackLocale;
  config.debug = options.debug !== undefined ? options.debug : dev;
}

export function initLocale(options: InitLocaleOptions = {}): void {
  const opts: Required<InitLocaleOptions> = {
    preferBrowser: true,
    preferStorage: true,
    defaultLocale: config.fallbackLocale,
    ...options
  };

  let detectedLocale: Locale | null = null;

  if (opts.preferStorage && config.persistLocale) {
    const saved = getSavedLocale();
    if (saved !== config.fallbackLocale) detectedLocale = saved;
  }

  if (!detectedLocale && opts.preferBrowser) {
    const browserLocale = detectBrowserLocale();
    if (browserLocale !== config.fallbackLocale) detectedLocale = browserLocale;
  }

  void setLocale(detectedLocale ?? opts.defaultLocale, { silent: true });

  if (config.debug) {
    console.log(`i18n initialized. Locale set to: ${currentLocale}.`);
  }
}

export async function setLocale(newLocale: Locale, options: SetLocaleOptions = {}): Promise<void> {
  const { silent = false } = options;

  if (failedLocaleLoads[newLocale]) {
    if (!silent) console.warn(`Locale '${newLocale}' previously failed to load. Using fallback '${config.fallbackLocale}'.`);
    if (currentLocale === newLocale) currentLocale = config.fallbackLocale;
    return;
  }

  currentLocale = newLocale;

  if (newLocale !== 'en' && !translations[newLocale]) {
    if (config.debug) console.log(`Loading translations for locale: ${newLocale}`);
    try {
      const module = await import(`./translations/${newLocale}.json`);
      translations[newLocale] = module.default as unknown as Paths<typeof en>;
      failedLocaleLoads[newLocale] = false;
      if (config.debug) console.log(`Successfully loaded locale: ${newLocale}`);
    } catch (error) {
      failedLocaleLoads[newLocale] = true;
      if (!silent) console.error(`Failed to load translations for locale: ${newLocale}`, error);
      if (currentLocale === newLocale) {
        currentLocale = config.fallbackLocale;
        if (!silent) console.warn(`Falling back to locale: ${config.fallbackLocale}`);
      }
    }
  } else if (translations[newLocale]) {
    if (config.debug) console.log(`Locale switched to already loaded: ${newLocale}`);
  }
}

export function t(
  key: Translations[Locale],
  params?: Record<string, unknown>,
  count?: number
): string {
  const localeToUse = currentLocale;
  const translationValue = findTranslationValue(key, localeToUse, config.fallbackLocale, translations);

  if (translationValue !== undefined) {
    if (typeof translationValue === 'object' && translationValue !== null && count !== undefined) {
      const pluralCategory = getPluralCategory(localeToUse, count);
      const pluralForm = (translationValue as PluralObject)[pluralCategory] ?? (translationValue as PluralObject)['other'];
      if (typeof pluralForm === 'string') {
        return applyParams(pluralForm, { ...params, count });
      }
    } else if (typeof translationValue === 'string') {
      return applyParams(translationValue, params);
    }
  }

  if (config.debug) {
    console.warn(`Translation key not found: '${key}' (locale: ${localeToUse})`);
    return `[${key}]`;
  }

  const parts = key.split('.');
  return parts[parts.length - 1] || key;
}

declare global {
  interface Window {
    __i18nMissingKeys?: Set<string>;
  }
}
